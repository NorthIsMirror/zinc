

# AUTOGENERATED - DO NOT EDIT
# vim: ft=zsh ts=2 sw=2 et fenc=utf-8

function p10ks_vcs () {
  _P10K_DBG_OUT "p10ks_vcs replying with: ${p10ks_vcs["_info_msg_0_"]}"
  REPLY="${p10ks_vcs["_info_msg_0_"]}"
}

typeset -gA p10ks_vcs
p10ks_vcs["_info_msg_0_"]="<async:vcs>"
p10ks_vcs[status]="loading"

p10ks_vcs "$@"

# AUTOGENERATED - DO NOT EDIT

# AUTOGENERATED - DO NOT EDIT
# vim: ft=zsh ts=2 sw=2 et fenc=utf-8

function p10ks_vcs_default_opts () {
  reply=(black CONDITIONAL CONDITIONAL async)
}

# AUTOGENERATED - DO NOT EDIT

# AUTOGENERATED - DO NOT EDIT
# vim: ft=zsh ts=2 sw=2 et fenc=utf-8

function p10ks_vcs_display_hidden () {
  [[ "${p10ks_vcs["_info_msg_0_"]}" == "" ]] && true || false
}

# AUTOGENERATED - DO NOT EDIT

# AUTOGENERATED - DO NOT EDIT
# vim: ft=zsh ts=2 sw=2 et fenc=utf-8

function p10ks_vcs_bg () {
  case "${p10ks_vcs[status]}" in
    "dirty") REPLY=${p10ks_vcs[color_dirty]} ;;
    "loading") REPLY=${p10ks_vcs[color_loading]} ;;
    *) REPLY=${p10ks_vcs[color_default]} ;;
  esac
}

p10ks_vcs[color_dirty]=${p10ks_vcs[color_dirty]:-"yellow"}
p10ks_vcs[color_loading]=${p10ks_vcs[color_loading]:-"8"}
p10ks_vcs[color_default]=${p10ks_vcs[color_default]:-"green"}

p10ks_vcs_bg "$@"

# AUTOGENERATED - DO NOT EDIT

# AUTOGENERATED - DO NOT EDIT


# AUTOGENERATED - DO NOT EDIT

# AUTOGENERATED - DO NOT EDIT
# vim: ft=zsh ts=2 sw=2 et fenc=utf-8

autoload -Uz vcs_info

p10ks_vcs_async ()
{
  vcs_info
  printf '%b' "${VCS_WORKDIR_DIRTY},;;;${vcs_info_msg_0_}"
}

# HACK/TODO ex. from my personal shell
zstyle ':vcs_info:svn*:*' actionformats '%c%u %F{red}| %a%f'
zstyle ':vcs_info:*' actionformats '%b %F{red}| %a%f'
# TODO unicode
zstyle ':vcs_info:hg*:*' branchformat ' %b'
# TODO unicode
zstyle ':vcs_info:git*:*' branchformat ' %b'
zstyle ':vcs_info:*' check-for-changes true
zstyle ':vcs_info:*' enable git hg svn
zstyle ':vcs_info:svn*:*' formats %c%u
zstyle ':vcs_info:*' formats %b%c%u%m
zstyle ':vcs_info:hg*:*' get-bookmarks true
zstyle ':vcs_info:hg*:*' get-revision true
zstyle ':vcs_info:hg*+gen-hg-bookmark-string:*' hooks hg-bookmarks
# TODO unicode
zstyle ':vcs_info:*' stagedstr ' ✚'
# TODO unicode
zstyle ':vcs_info:*' unstagedstr ' ●'

# VCS_INFO HOOKS
zstyle ':vcs_info:git*+set-message:*' hooks \n vcs-detect-changes git-untracked git-aheadbehind git-stash git-remotebranch git-tagname
zstyle ':vcs_info:hg*+set-message:*' hooks \n vcs-detect-changes hg-branchhead
zstyle ':vcs_info:svn*+set-message:*' hooks \n vcs-detect-changes svn-detect-changes

### Generic hook functions
function +vi-vcs-detect-changes() {
  if [[ "${hook_com[vcs]}" == "hg" ]]; then
    vcs_visual_identifier='VCS_HG_ICON'
  elif [[ "${hook_com[vcs]}" == "svn" ]]; then
    vcs_visual_identifier='VCS_SVN_ICON'
  fi

  if [[ -n "${hook_com[staged]}" ]] || [[ -n "${hook_com[unstaged]}" ]]; then
    VCS_WORKDIR_DIRTY=1
  else
    VCS_WORKDIR_DIRTY=0
  fi
}

### GIT hook functions

function +vi-git-untracked(){
  if [[ $(git rev-parse --is-inside-work-tree 2> /dev/null) == 'true' ]] && \n    git status --porcelain | grep '??' &> /dev/null ; then
    # This will show the marker if there are any untracked files in repo.
    # If instead you want to show the marker only if there are untracked
    # files in $PWD, use:
    #[[ -n $(git ls-files --others --exclude-standard) ]] ; then
    # TODO unicode
    hook_com[unstaged]+='◌'
  fi
}

function +vi-git-aheadbehind() {
  local ahead behind
  local -a gitstatus

  # for git prior to 1.7
  # ahead=$(git rev-list origin/${hook_com[branch]}..HEAD | wc -l)
  ahead=$(git rev-list ${hook_com[branch]}@{upstream}..HEAD 2>/dev/null | wc -l)
  # TODO unicode
  (( $ahead )) && gitstatus+=( " +${ahead}" )

  # for git prior to 1.7
  # behind=$(git rev-list HEAD..origin/${hook_com[branch]} | wc -l)
  behind=$(git rev-list HEAD..${hook_com[branch]}@{upstream} 2>/dev/null | wc -l)
  # TODO unicode
  (( $behind )) && gitstatus+=( " -${behind}" )

  hook_com[misc]+=${(j:/:)gitstatus}
}

# function +vi-git-remotebranch() {
#   local remote
#
#   # Are we on a remote-tracking branch?
#   remote=${$(git rev-parse --verify ${hook_com[branch]}@{upstream} \n#     --symbolic-full-name 2>/dev/null)/refs/remotes/}
#
#   # The first test will show a tracking branch whenever there is one. The
#   # second test, however, will only show the remote branch's name if it
#   # differs from the local one.
#   if [[ -n ${remote} ]] ; then
#   #if [[ -n ${remote} && ${remote#*/} != ${hook_com[branch]} ]] ; then
#     # TODO unicode
#     hook_com[branch]=" ${hook_com[branch]} [${remote}]"
#   fi
# }

### HG hook functions

function +vi-hg-storerev() {
  user_data[hash]=${hook_com[hash]}
}

function +vi-hg-branchhead() {
  local branchheadsfile i_tiphash i_branchname
  local -a branchheads

  local branchheadsfile=${hook_com[base]}/.hg/branchheads.cache

  # Bail out if any mq patches are applied
  [[ -s ${hook_com[base]}/.hg/patches/status ]] && return 0

  if [[ -r ${branchheadsfile} ]] ; then
    while read -r i_tiphash i_branchname ; do
      branchheads+=( $i_tiphash )
    done < ${branchheadsfile}

    if [[ ! ${branchheads[(i)${user_data[hash]}]} -le ${#branchheads} ]] ; then
      hook_com[revision]="^ ${hook_com[revision]}"
    fi
  fi
}

### Definitions done

p10ks_vcs_async "$@"

# AUTOGENERATED - DO NOT EDIT

# AUTOGENERATED - DO NOT EDIT
# vim: ft=zsh ts=2 sw=2 et fenc=utf-8

p10ks_vcs_async_return ()
{
  # $1 return code
  # $2 resulting (stdout) output from job execution
  # $3 execution time, floating point e.g. 0.0076138973 seconds
  # $4 resulting (stderr) error output from job execution

  _P10K_DBG_OUT "p10ks_vcs working out input: $2"
  local -a tmp
  tmp=("${(s.;;;.)2}")
  p10ks_vcs["_info_msg_0_"]="${tmp[2]}"
  tmp=("${(s.,.)tmp}")
  (( ${tmp[1]} )) && p10ks_vcs[status]="dirty" || p10ks_vcs[status]="returned"
}

p10ks_vcs_async_return "$@"

# AUTOGENERATED - DO NOT EDIT

# AUTOGENERATED - DO NOT EDIT
# vim: ft=zsh ts=2 sw=2 et fenc=utf-8

p10ks_vcs_async_started ()
{
  _P10K_DBG_OUT "p10ks_vcs_async_started called..."
  # _display_hidden is hooked on the empty scalar:
  p10ks_vcs["_info_msg_0_"]="<loading...>"
  p10ks_vcs[status]="loading"
}

[[ "${(t)p10ks_vcs}" != "association" ]] && {
  typeset -gA p10ks_vcs
}

function _p10ks_vcs_async_complete () {
  _p10k_segment_async_reset_status p10ks_vcs
}

_p10k_add_hook _p10k_async_complete _p10ks_vcs_async_complete

p10ks_vcs_async_started "$@"

# AUTOGENERATED - DO NOT EDIT

vcs_info() {
## vim:ft=zsh:foldmethod=marker
##
## vcs_info - provide version control information
##
## Written by Frank Terbeck <ft@bewatermyfriend.org>
##
## This file and all corresponding files in Functions/VCS_Info/ are
## distributed under the same BSD-ish license as zsh itself.
##

setopt localoptions noksharrays extendedglob NO_shwordsplit
local file func sys
local -a static_functions msgs
local -i maxexports

static_functions=(
    VCS_INFO_adjust
    VCS_INFO_bydir_detect
    VCS_INFO_check_com
    VCS_INFO_formats
    VCS_INFO_get_cmd
    VCS_INFO_hexdump
    VCS_INFO_hook
    VCS_INFO_set-patch-format
    VCS_INFO_maxexports
    VCS_INFO_nvcsformats
    VCS_INFO_patch2subject
    VCS_INFO_quilt
    VCS_INFO_realpath
    VCS_INFO_reposub
    VCS_INFO_set

    vcs_info_hookadd
    vcs_info_hookdel
    vcs_info_lastmsg
    vcs_info_printsys
    vcs_info_setsys
)

for func in ${static_functions} ; do
    autoload -Uz ${func}
done

[[ -n ${(Mk)parameters:#vcs_info_msg_<->_} ]] && unset ${parameters[(I)vcs_info_msg_<->_]}
VCS_INFO_maxexports
VCS_INFO_set --nvcs '-preinit-'
vcs_info_setsys

# and now, finally create the real vcs_info function
vcs_info () {
    emulate -L zsh
    setopt extendedglob NO_warn_create_global

    [[ -r . ]] || return 0

    local pat
    local -i found retval
    local -a enabled disabled dps
    local usercontext vcs rrn quiltmode
    local -x LC_MESSAGES
    local -i maxexports
    local -a msgs
    local -A vcs_comm hook_com backend_misc user_data

    LC_MESSAGES=C
    if [[ -n ${LC_ALL} ]]; then
        local -x LANG
        LANG=${LC_ALL}
        local -x LC_ALL
    fi
    vcs='-init-'; rrn='-all-'; quiltmode='addon'
    usercontext=${1:-default}

    VCS_INFO_hook "start-up"
    retval=$?
    if (( retval == 1 )); then
        return 0
    elif (( retval == 2 )); then
        # This needs `max-exports' set. We're still setting it again later
        # for more specific contexts.
        VCS_INFO_maxexports
        VCS_INFO_set --nvcs
        return 0
    fi

    zstyle -a ":vcs_info:${vcs}:${usercontext}:${rrn}" "enable" enabled
    (( ${#enabled} == 0 )) && enabled=( all )

    if [[ -n ${(M)enabled:#(#i)none} ]] ; then
        [[ -n ${vcs_info_msg_0_} ]] && VCS_INFO_set --nvcs
        return 0
    fi

    if [[ -n ${(M)enabled:#(#i)all} ]] ; then
        enabled=( ${VCS_INFO_backends} )
        zstyle -a ":vcs_info:${vcs}:${usercontext}:${rrn}" "disable" disabled
    fi

    zstyle -a ":vcs_info:${vcs}:${usercontext}:${rrn}" "disable-patterns" dps

    for pat in ${dps} ; do
        if [[ ${PWD} == ${~pat} ]] ; then
            VCS_INFO_maxexports
            [[ -n ${vcs_info_msg_0_} ]] && VCS_INFO_set --nvcs
            return 0
        fi
    done

    VCS_INFO_maxexports

    (( found = 0 ))
    for vcs in ${enabled} ; do
        [[ -n ${(M)disabled:#${vcs}} ]] && continue
        if (( ${+functions[VCS_INFO_detect_${vcs}]} == 0 )) ; then
            printf 'vcs_info: configured unknown backend: '\''%s'\''\n' ${vcs}
            printf 'vcs_info: use '\''vcs_info_printsys'\'' to find supported systems.\n'
            continue
        fi
        vcs_comm=()
        VCS_INFO_get_cmd
        VCS_INFO_detect_${vcs} && (( found = 1 )) && break
    done

    (( found == 0 )) && {
        vcs='-quilt-'; quiltmode='standalone'
        VCS_INFO_quilt standalone || VCS_INFO_set --nvcs
        return 0
    }

    VCS_INFO_hook "pre-get-data"
    retval=$?
    if (( retval == 1 )); then
        return 0
    elif (( retval == 2 )); then
        VCS_INFO_set --nvcs
        return 0
    fi

    VCS_INFO_get_data_${vcs} || {
        VCS_INFO_set --nvcs
        return 1
    }

    VCS_INFO_set
    return 0
}

vcs_info "$@"
}
