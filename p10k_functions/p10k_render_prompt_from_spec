# vim: ft=zsh ts=2 sw=2 et fenc=utf-8

function p10k_render_prompt_from_spec () {
  _P10K_DBG_OUT "\n>>> build_prompt: $1 $2"
  # Builds the prompt with the given name.
  #
  # $1: Name of a p10k prompt segment array. Required.
  # $2: Name of a p10k segment options array.
  # $3: Render direction
  # $4: Chars to use as segment separator.

  local _P10K_SBUF=""

  # HACK
  # _P10K_DBG_OUT "_P10K_ASYNC_STATII: ${(kv)_P10K_ASYNC_STATII}"

  # TODO OPTI
  [[ "${(P)#1}" == "0" ]] && echo 'ERR: no segments' && return
  _P10K_DBG_OUT "${(P)#1} segments to render"

  # Character separator
  [[ $3 == "right" ]] && P10K_SEP_CHAR=${4:-''} \
  || P10K_SEP_CHAR=${4:-''}

  local prev_bg
  [[ $3 != "right" ]] && prev_bg="NOCONNECT"
  local -A _p10k_opts
  _p10k_opts=(${(kvP)${2}})
  local -a segment_opts
  local segment_optstr

  for cur_segment in ${(P)${1}}; do

    # Autoload function
    # TODO OPTI
    (( ${+functions[${cur_segment}]} )) || {
      # _P10K_DBG_OUT "need to load $cur_segment X"
      builtin autoload -U +X $cur_segment
      _P10K_AUTOLOADED_FUNCTIONS+=("$cur_segment")
    }

    # Get segment options, fill needed defaults
    segment_optstr="${_p10k_opts[$cur_segment]}"
    segment_opts=("${(@s.;.)segment_optstr}")
    _P10K_DBG_OUT "$cur_segment opts before default application: ${segment_opts}"
    for segment_opt_number in {1..4}; do
      [[ "${segment_opts[$segment_opt_number]}" == "" ]] && {
        # then we need to get the default opt here
        (( ${_P10K_SEGMENT_DEFAULTS[${cur_segment}_${segment_opt_number}]} )) || {
          _P10K_DBG_OUT "getting default opts for $cur_segment ${segment_opt_number}"
          (( ${+functions[${cur_segment}_default_opts]} )) || {
            builtin autoload -Uz +X "${cur_segment}_default_opts"
            _P10K_AUTOLOADED_FUNCTIONS+="${cur_segment}_default_opts"
          }
          ${cur_segment}_default_opts
          local -a new_segment_opts=("${(@s.;.)reply}")
          _P10K_DBG_OUT "$cur_segment default opts: ${new_segment_opts}"
          for v in {1..4}; do
            _P10K_SEGMENT_DEFAULTS[${cur_segment}_${v}]=${new_segment_opts[${v}]}
          done
        }
        # set the value from _P10K_SEGMENT_DEFAULTS cache
        segment_opts[${segment_opt_number}]="${_P10K_SEGMENT_DEFAULTS[${cur_segment}_${segment_opt_number}]}"
      }
    done
    _P10K_DBG_OUT "$cur_segment opts after default application: ${segment_opts}"
    # _P10K_DBG_OUT "opts for "$cur_segment':' "${(j.,.)segment_opts}"

    # Detect segments with asynchronous output enabled
    # async status "" means not yet started
    [[ ${segment_opts[4]} == "async" ]] && \
    [[ "${_P10K_ASYNC_STATII[${cur_segment}_async]}" == "" ]] && {
      (( ${+functions[${cur_segment}_async]} )) || {
        builtin autoload -U +X ${cur_segment}_async
        _P10K_AUTOLOADED_FUNCTIONS+=("${cur_segment}_async")
      }
      async_worker_eval p10k_segment_worker "autoload" "-U" "+X" "${cur_segment}_async"
      [[ "${(t)_P10K_ASYNC_STATII}" == "association" ]] || typeset -A _P10K_ASYNC_STATII
      (( ${+functions[${cur_segment}_async_started]} )) || {
        builtin autoload -U +X ${cur_segment}_async_started
        _P10K_AUTOLOADED_FUNCTIONS+=("${cur_segment}_async_started")
      }
      ${cur_segment}_async_started "${(@)segment_opts}"
      _P10K_ASYNC_STATII[${cur_segment}_async]="started"
      async_job p10k_segment_worker "${cur_segment}_async" "${(@)segment_opts}"
    }

    # HACK
    # _P10K_DBG_OUT "_P10K_ASYNC_STATII: ${(kv)_P10K_ASYNC_STATII}"

    # Detect segments with conditional display
    if [[ "${segment_opts[3]}" == "CONDITIONAL" ]]; then
      (( ${+functions[${cur_segment}_display_hidden]} )) || {
        builtin autoload -U +X ${cur_segment}_display_hidden
        _P10K_AUTOLOADED_FUNCTIONS+=("${cur_segment}_display_hidden")
      }
      ${cur_segment}_display_hidden && {
        _P10K_DBG_OUT "not displaying ${cur_segment}"
        continue
      }
    fi

    # Detect segments with conditional colors
    if [[ "${segment_opts[1]}" == "CONDITIONAL" ]]; then
      (( ${+functions[${cur_segment}_fg]} )) || \
        builtin autoload -U +X ${cur_segment}_fg
      segment_opts[1]="$(${cur_segment}_fg)"
    fi
    if [[ ${segment_opts[2]} == "CONDITIONAL" ]]; then
      (( ${+functions[${cur_segment}_bg]} )) || \
        builtin autoload -U +X ${cur_segment}_bg
      segment_opts[2]="$(${cur_segment}_bg)"
    fi

    # Detect segment connection
    if [[ $prev_bg == "NOCONNECT" ]] || [[ ${segment_opts[3]} == "CONNECT_PREV" ]]; then
      # skip drawing the arrow
      builtin printf '%b' '%K{'${segment_opts[2]}'} '
    else
      [[ "$3" != "right" ]] && builtin printf '%b' ' %K{'${segment_opts[2]}'}%F{'${prev_bg}'}'${P10K_SEP_CHAR}' ' \
      || printf '%b' ' %F{'${segment_opts[2]}'}'${P10K_SEP_CHAR}'%K{'${segment_opts[2]}'} '
    fi

    # print actual segment content
    builtin printf '%b' '%F{'${segment_opts[1]}'}'
    # [[ ${segment_opts[4]} == "async" ]] && {
    #   [[ "${_P10K_ASYNC_STATII[${cur_segment}_async]}" == "returned" ]] \
    #   && ${cur_segment}_async
    # } || {
      ${cur_segment} "${(@)segment_opts}"
    # }

    # store for next loop
    prev_bg="${segment_opts[2]}"
  done

  # finish the prompt line:
  # the `%{ %}` is an invis wrapper
  [[ "$3" != "right" ]] && builtin printf '%b' ' %k%F{'${prev_bg}'}'${P10K_SEP_CHAR}'%f ' \
  || builtin printf '%b' '%{ %}%k%f'

}

_P10K_AUTOLOADED_FUNCTIONS+=("p10k_render_prompt_from_spec")

p10k_render_prompt_from_spec "$@"
