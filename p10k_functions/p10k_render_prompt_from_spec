# vim: ft=zsh ts=2 sw=2 et fenc=utf-8

function p10k_render_prompt_from_spec () {
  _P10K_DBG_OUT "\n>>> build_prompt: $1 $2"
  # Builds the prompt with the given name.
  #
  # $1: Name of a p10k prompt segment array. Required.
  # $2: Name of a p10k segment options array.
  # $3: Render direction
  # $4: Chars to use as segment separator.

  local _P10K_SBUF=""

  # HACK
  # _P10K_DBG_OUT "_P10K_ASYNC_STATII: ${(kv)_P10K_ASYNC_STATII}"

  # TODO OPTI
  [[ "${(P)#1}" == "0" ]] && echo 'ERR: no segments' && return
  _P10K_DBG_OUT "${(P)#1} segments to render"

  # Character separator
  [[ $3 == "right" ]] && P10K_SEP_CHAR=${4:-''} \
  || P10K_SEP_CHAR=${4:-''}

  local prev_bg
  [[ $3 != "right" ]] && prev_bg="NOCONNECT"
  local -A _p10k_opts
  _p10k_opts=(${(kvP)${2}})
  local -a segment_opts
  local segment_optstr

  for cur_segment in ${(P)${1}}; do

    # Autoload function
    _p10k_tracked_autoload $cur_segment

    # Get segment options, fill needed defaults
    segment_optstr="${_p10k_opts[$cur_segment]}"
    segment_opts=("${(@s.;.)segment_optstr}")
    # _P10K_DBG_OUT "$cur_segment opts before default application: ${segment_opts}"
    for segment_opt_number in {1..4}; do
      [[ "${segment_opts[$segment_opt_number]}" == "" ]] && {
        # then we need to get the default opt here
        (( ${_P10K_SEGMENT_DEFAULTS[${cur_segment}_${segment_opt_number}]} )) || {
          # _P10K_DBG_OUT "getting default opts for $cur_segment ${segment_opt_number}"
          _p10k_tracked_autoload "${cur_segment}_default_opts"
          ${cur_segment}_default_opts
          local -a new_segment_opts=("${(@s.;.)reply}")
          # _P10K_DBG_OUT "$cur_segment default opts: ${new_segment_opts}"
          for v in {1..4}; do
            _P10K_SEGMENT_DEFAULTS[${cur_segment}_${v}]=${new_segment_opts[${v}]}
          done
        }
        # set the value from _P10K_SEGMENT_DEFAULTS cache
        segment_opts[${segment_opt_number}]="${_P10K_SEGMENT_DEFAULTS[${cur_segment}_${segment_opt_number}]}"
      }
    done
    # _P10K_DBG_OUT "$cur_segment opts after default application: ${segment_opts}"
    # _P10K_DBG_OUT "opts for "$cur_segment':' "${(j.,.)segment_opts}"

    # Detect segments with asynchronous output enabled
    # async status "" means not yet started
    [[ ${segment_opts[4]} == "async" ]] && \
    [[ "${_P10K_ASYNC_STATII[${cur_segment}_async]}" == "" ]] && {
      _p10k_tracked_autoload "${cur_segment}_async"
      async_worker_eval p10k_segment_worker "autoload" "-Uz" "+X" "${cur_segment}_async"
      [[ "${(t)_P10K_ASYNC_STATII}" == "association" ]] || typeset -A _P10K_ASYNC_STATII
      _p10k_tracked_autoload "${cur_segment}_async_started"
      ${cur_segment}_async_started "${(@)segment_opts}"
      _P10K_ASYNC_STATII[${cur_segment}_async]="started"
      async_job p10k_segment_worker "${cur_segment}_async" "${(@)segment_opts}"
    }

    # Run the segment and gather output:
    REPLY=""
    ${cur_segment} "${(@)segment_opts}"
    local segment_output="$REPLY"

    # Detect segments with conditional display
    if [[ "${segment_opts[3]}" == "CONDITIONAL" ]]; then
      _p10k_tracked_autoload "${cur_segment}_display_hidden"
      ${cur_segment}_display_hidden && {
        _P10K_DBG_OUT "not displaying ${cur_segment}"
        continue
      }
    fi

    # Detect segments with conditional colors
    if [[ "${segment_opts[1]}" == "CONDITIONAL" ]]; then
      _p10k_tracked_autoload "${cur_segment}_fg"
      segment_opts[1]="$(${cur_segment}_fg)"
    fi
    if [[ ${segment_opts[2]} == "CONDITIONAL" ]]; then
      _p10k_tracked_autoload "${cur_segment}_bg"
      segment_opts[2]="$(${cur_segment}_bg)"
    fi

    # Detect segment connection
    if [[ $prev_bg == "NOCONNECT" ]] || [[ ${segment_opts[3]} == "CONNECT_PREV" ]]; then
      # skip drawing the arrow
      _P10K_SBUF+="%K{${segment_opts[2]}} "
    else
      [[ "$3" != "right" ]] && _P10K_SBUF+=" %K{${segment_opts[2]}}%F{${prev_bg}}${P10K_SEP_CHAR} " \
      || _P10K_SBUF+=" %F{${segment_opts[2]}}${P10K_SEP_CHAR}%K{${segment_opts[2]}} "
    fi

    # print actual segment content
    _P10K_SBUF+="%F{${segment_opts[1]}}"
    _P10K_SBUF+="${segment_output}"

    # store for next loop
    prev_bg="${segment_opts[2]}"
  done

  # finish the prompt line:
  # the `%{ %}` is an invis wrapper
  [[ "$3" != "right" ]] && _P10K_SBUF+=' %k%F{'${prev_bg}'}'${P10K_SEP_CHAR}'%f ' \
  || _P10K_SBUF+='%{ %}%k%f'

  REPLY="$_P10K_SBUF"

  _P10K_DBG_OUT "<<< render done."
}

_P10K_AUTOLOADED_FUNCTIONS+=("p10k_render_prompt_from_spec")

p10k_render_prompt_from_spec "$@"
