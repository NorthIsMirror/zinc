# vim: ft=zsh ts=2 sw=2 et fenc=utf-8
#
# P10K
#
# A powerline ZSH theme, inspired by Powerlevel9k and friends.

_P10K_DBG_OUT () {
  # ' >/tmp/_P10K_DBG_OUT.log 2>&1'
  echo "$@" >>/tmp/_P10K_DBG_OUT.log
}

typeset -aU _P10K_AUTOLOADED_FUNCTIONS
function p10k_reload () {
  for segment_function in $_P10K_AUTOLOADED_FUNCTIONS; do
    unfunction $segment_function
    autoload -U $segment_function
  done
  unfunction prompt_p10k_setup
  autoload -U prompt_p10k_setup
}

function p10k_build_prompt_from_spec () {
  _P10K_RETVAL_STORE=$?
  _P10K_RETVAL_STOREs=( "$pipestatus[@]" )
  # Builds the prompt with the given name.
  #
  # $1: Name of a p10k prompt segment array.
  # $2: Name of a p10k segment options array.
  # $3: Render direction
  # $4: Chars to use as segment separator.

  [[ $3 == "right" ]] && P10K_SEP_CHAR=${4:-''} \
  || P10K_SEP_CHAR=${4:-''}

  local prev_bg="NOCONNECT"
  local -A _p10k_opts
  _p10k_opts=(${(kvP)${2}})

  local -a segment_opts
  local segment_optstr

  for cur_segment in ${(P)${1}}; do

    # Autoload function
    if (( ${+functions[${cur_segment}]} )); then
      # function is already loaded
      _P10K_DBG_OUT function $cur_segment already exists
    else
      # function needs to be loaded
      _P10K_DBG_OUT need to load $cur_segment
      builtin autoload -U $cur_segment
    fi

    # Get segment options
    segment_optstr="${_p10k_opts[$cur_segment]}"
    if [[ -z "${segment_optstr}" ]]; then
      (( ${+functions[${cur_segment}_default_opts]} )) || \
        builtin autoload -Uz "${cur_segment}_default_opts"
      segment_optstr="$(${cur_segment}_default_opts)"
      # _P10K_DBG_OUT 'using default opts for '$cur_segment
      # _P10K_DBG_OUT $segment_optstr
    fi
    segment_opts=("${(@s.;.)segment_optstr}")
    # _P10K_DBG_OUT "opts for "$cur_segment':' "${(j.,.)segment_opts}"

    # Get segment text
    local segment_text="$(${cur_segment} "${(@)segment_opts}")"
    # _P10K_DBG_OUT $segment_text

    # Detect segments with conditional colors
    if [[ "${segment_opts[1]}" == "CONDITIONAL" ]]; then
      (( ${+functions[${cur_segment}_fg]} )) || \
        builtin autoload -Uz ${cur_segment}_fg
      segment_opts[1]="$(${cur_segment}_fg)"
    fi
    if [[ ${segment_opts[2]} == "CONDITIONAL" ]]; then
      (( ${+functions[${cur_segment}_bg]} )) || \
        builtin autoload -Uz ${cur_segment}_bg
      segment_opts[2]="$(${cur_segment}_bg)"
    fi

    # Detect segment connection
    if [[ $prev_bg == "NOCONNECT" ]] || [[ ${segment_opts[3]} == "CONNECT_PREV" ]]; then
      # skip drawing the arrow
      printf '%b' '%K{'${segment_opts[2]}'} '
    else
      printf '%b' ' %K{'${segment_opts[2]}'}%F{'${prev_bg}'}'${P10K_SEP_CHAR}' '
    fi
    printf '%b' '%F{'${segment_opts[1]}'}'
    printf '%b' "$segment_text"
    prev_bg="${segment_opts[2]}"
  done

  # finish the prompt line:
  printf '%b' ' %k%F{'${prev_bg}'}'${P10K_SEP_CHAR}'%f '

}

prompt_p10k_setup () {
  PS1="%f%b%k\$(p10k_build_prompt_from_spec p10k_left p10k_left_opts)"
  RPROMPT="${RPROMPT_PREFIX}"'%f%b%k$(p10k_build_prompt_from_spec p10k_right p10k_right_opts right)%f%b%k'"${RPROMPT_SUFFIX}"

  prompt_opts=( cr percent sp subst )
  setopt noprompt{cr,percent,sp,subst} "prompt${^prompt_opts[@]}"

  _P10K_RETVAL_STORE="0"

}

prompt_p10k_setup "$@"
