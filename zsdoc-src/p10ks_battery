

# AUTOGENERATED - DO NOT EDIT
# vim: ft=zsh ts=2 sw=2 et fenc=utf-8

# synopsis {{{
# Battery segment that displays percent charge,
# reacts to charging/discharging/charged,
# and has other options.
# }}}

# awaiting https://github.com/zdharma/zshelldoc/issues/8
# update: works now
# env-vars {{{
typeset -gA p10ks_battery
p10ks_battery[percent]=""
# p10ks_battery[verbose] -> 0/1: enables showing time until full/empty (requiress acpi)
p10ks_battery[verbose]="${p10ks_battery[verbose]:-1}"
# }}}

# P10K Battery segment
# Mostly stolen code from P9K
function p10ks_battery () {
  (( ${p10ks_battery[verbose]} )) && {
    if [[ -n ${p10ks_battery[time_remaining]} ]]; then
      REPLY="${p10ks_battery[percent]}%% (${p10ks_battery[time_remaining]})"
    else
      # continue to else case below
      false
    fi
  } || {
    REPLY="${p10ks_battery[percent]}%%"
  }
}

p10ks_battery "$@"

# AUTOGENERATED - DO NOT EDIT

# AUTOGENERATED - DO NOT EDIT
# vim: ft=zsh ts=2 sw=2 et fenc=utf-8

function p10ks_battery_default_opts () {
  reply=(CONDITIONAL CONDITIONAL CONDITIONAL async)
}

# AUTOGENERATED - DO NOT EDIT

# AUTOGENERATED - DO NOT EDIT
# vim: ft=zsh ts=2 sw=2 et fenc=utf-8

function p10ks_battery_display_hidden () {
  if [[ ${p10ks_battery[state]} == "charged" ]]; then
    return 0
  elif [[ ${p10ks_battery[state]} == "disconnected" ]]; then
    return 1
  elif (( p10ks_battery[percent] >= p10ks_battery[threshold_hidden] )); then
    true
  elif [[ ${p10ks_battery[state]} == "unknown" ]] || [[ ${p10ks_battery[state]} == "" ]]; then
    # battery not supported on this system?
    _P10K_DBG_OUT "Not showing battery segment: unknown status."
    true
  else
    false
  fi
}

[[ "${(t)p10ks_battery}" != "association" ]] && {
  typeset -gA p10ks_battery
}
# env-vars {{{
# p10ks_battery[threshold_hidden] -> hide the segment when above this percentage
p10ks_battery[threshold_hidden]=${p10ks_battery[threshold_hidden]:-"99"}
# }}}

p10ks_battery_display_hidden "$@"

# AUTOGENERATED - DO NOT EDIT

# AUTOGENERATED - DO NOT EDIT
# vim: ft=zsh ts=2 sw=2 et fenc=utf-8

function p10ks_battery_bg () {
  # change color based on charge level
  if (( p10ks_battery[percent] <= p10ks_battery[threshold_low] )); then
    REPLY="${p10ks_battery[bgcolor_low]}"
  elif (( p10ks_battery[percent] >= p10ks_battery[threshold_charged] )); then
    REPLY="${p10ks_battery[bgcolor_charged]}"
  else
    REPLY="${p10ks_battery[bgcolor_default]}"
  fi
}

[[ "${(t)p10ks_battery}" != "association" ]] && {
  typeset -gA p10ks_battery
}

# env-vars {{{
# p10ks_battery[threshold_low] -> percentage
p10ks_battery[threshold_low]=${p10ks_battery[threshold_low]:-"30"}
# p10ks_battery[threshold_charged] -> percentage
p10ks_battery[threshold_charged]=${p10ks_battery[threshold_charged]:-"95"}
# p10ks_battery[bgcolor_default] -> bgcolor when not low or charged
p10ks_battery[bgcolor_default]="${p10ks_battery[bgcolor_default]:-black}"
# p10ks_battery[bgcolor_low] -> color when below threshold_low
p10ks_battery[bgcolor_low]="${p10ks_battery[bgcolor_low]:-red}"
# p10ks_battery[bgcolor_charged] -> color when above threshold_charged
p10ks_battery[bgcolor_charged]="${p10ks_battery[bgcolor_charged]:-${p10ks_battery[bgcolor_default]}}"
# }}}

p10ks_battery_bg "$@"

# AUTOGENERATED - DO NOT EDIT

# AUTOGENERATED - DO NOT EDIT
# vim: ft=zsh ts=2 sw=2 et fenc=utf-8

# env-vars {{{
[[ "${(t)p10ks_battery}" != "association" ]] && {
  typeset -gA p10ks_battery
}
p10ks_battery[threshold_low]=${p10ks_battery[threshold_low]:-"30"}
# p10ks_battery[fgcolor_low] -> color of text when battery below threshold_low
p10ks_battery[fgcolor_low]="${p10ks_battery[fgcolor_low]:-black}"
# p10ks_battery[fgcolor_charging] -> color of text when charging
p10ks_battery[fgcolor_charging]="${p10ks_battery[fgcolor_charging]:-green}"
# p10ks_battery[fgcolor_default] -> default foreground color
p10ks_battery[fgcolor_default]="${p10ks_battery[fgcolor_default]:-white}"
# }}}

# Change fg color based on low, charging, or default.
function p10ks_battery_fg () {
  # change color based on charge level
  if (( p10ks_battery[percent] <= p10ks_battery[threshold_low] )); then
    REPLY="${p10ks_battery[fgcolor_low]}"
  # elif (( p10ks_battery[percent] >= p10ks_battery[threshold_hidden] )); then
  #   REPLY="${p10ks_battery[fgcolor_charged]}"
  elif [[ ${p10ks_battery[state]} == "charging" ]]; then
    REPLY="${p10ks_battery[fgcolor_charging]}"
  else
    REPLY="${p10ks_battery[fgcolor_default]}"
  fi
}

p10ks_battery_fg "$@"

# AUTOGENERATED - DO NOT EDIT

# AUTOGENERATED - DO NOT EDIT
# vim: ft=zsh ts=2 sw=2 et fenc=utf-8

if [[ "$(uname -s )" == "Linux" ]]; then
  function p10ks_battery_async () {
    # The battery can have four different states - default to 'unknown'.
    local current_state='unknown'
    local sysp="${ROOT_PREFIX}/sys/class/power_supply"
    local potential_bats=( "$sysp/*" )
    [[ ${#${(M)potential_bats:#*(BAT|battery)*}} ]] \n      && local bats=(${$(ls -d $sysp/(battery|BAT*))}) \n      || return

    local numerator="0"
    local denominator="0"
    local battery_status_full=true
    local battery_status_charging=false
    for bat in $bats; do
      numerator+="+ $(cat $bat/capacity) * $(cat $bat/(energy|charge)_full)"
      denominator+="+ $(cat $bat/(energy|charge)_full)"
      [[ $(cat $bat/status) != Full ]] && battery_status_full=false
      [[ $(cat $bat/status) == Charging ]] && battery_status_charging=true
    done

    local capacity=$(( ($numerator)/($denominator) ))
    [[ $capacity -gt 100 ]] \n      && local bat_percent=100 \n      || local bat_percent=$capacity
    [[ $battery_status_full == true || $battery_status_charging == true ]] \n      && local connected=true

    if [[ -z $connected ]]; then
      [[ $bat_percent -lt $P9K_BATTERY_LOW_THRESHOLD ]] \n        && current_state="low" \n        || current_state="disconnected"
    else
      [[ $bat_percent =~ 100 ]] && current_state="charged"
      [[ $bat_percent -lt 100 ]] && current_state="charging"
    fi
    if [[ -f ${ROOT_PREFIX}/usr/bin/acpi ]]; then
      declare -a acpi_lines
      acpi_lines=( "${(@f)$(${ROOT_PREFIX}/usr/bin/acpi)}" )
      local time_remaining=${${=${(M)acpi_lines:#*([[:digit:]][[:digit:]]:|rate)*}}[5]}
      unset acpi_lines

      if [[ $time_remaining =~ "rate" ]]; then
        local tstring="..."
      elif [[ $time_remaining =~ "[[:digit:]]+" ]]; then
        local tstring=${(f)$(date -u -d "$(echo $time_remaining)" +%k:%M 2> /dev/null)}
      fi
    fi
    # [[ -n $tstring ]] && local remain=" ($tstring)"

    [[ -z "${bat_percent}" ]] && return
    builtin print "${current_state};${bat_percent};${tstring}"
  }
else
  function p10ks_battery_async () {
    # no support for OS
  }
fi

p10ks_battery_async "$@"

# AUTOGENERATED - DO NOT EDIT

# AUTOGENERATED - DO NOT EDIT
# vim: ft=zsh ts=2 sw=2 et fenc=utf-8

function p10ks_battery_async_return () {
  _P10K_DBG_OUT "bat returned with ${2}"
  p10ks_battery[asyncdata]="${2}"
  local -a returndata
  returndata=(${(s.;.)2})
  p10ks_battery[state]="${returndata[1]}"
  p10ks_battery[percent]="${returndata[2]}"
  p10ks_battery[time_remaining]="${returndata[3]}"
}

p10ks_battery_async_return "$@"

# AUTOGENERATED - DO NOT EDIT

# AUTOGENERATED - DO NOT EDIT
# vim: ft=zsh ts=2 sw=2 et fenc=utf-8

function p10ks_battery_async_started () {
  # p10ks_battery[percent]="??"
  p10ks_battery[state]=""
  p10ks_battery[time_remaining]="..."
}

[[ "${(t)p10ks_battery}" != "association" ]] && {
  typeset -gA p10ks_battery
}

function _p10ks_battery_async_complete () {
  _p10k_segment_async_reset_status p10ks_battery
}

_p10k_add_hook _p10k_async_complete _p10ks_battery_async_complete

p10ks_battery_async_started "$@"

# AUTOGENERATED - DO NOT EDIT
